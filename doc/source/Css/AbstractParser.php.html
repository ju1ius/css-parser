<html>
    <head>
        <script
            type="text/javascript"
            src="../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php

namespace ju1ius\Css;

use ju1ius\Collections\ParameterBag;
use ju1ius\Text\Source;

use ju1ius\Css\Util\Charset;
use ju1ius\Css\ParserState;
use ju1ius\Css\Exception\ParseException;
use ju1ius\Css\Exception\RecoveredParseException;

/**
 * Provides generic parsing methods for Css\Parser
 *
 * @package Css
 */
abstract class AbstractParser
{
  protected
    $options,
    $source,
    $text,
    $current_position,
    $backtracking_position,
    $length,
    $state,
    $strict_parsing = false,
    $errors;
    
  /**
   * Available options:
   *  - strict boolean If true, throw ParseExceptions on error.
   *                    If false, recover errors according to http://www.w3.org/TR/CSS2/syndata.html#parsing-errors 
   *
   * @param array $options
   **/
  public function __construct(array $options = array())
  {
    $this-&gt;options = new ParameterBag(array(
      'strict_parsing' =&gt; false
    ));
    $this-&gt;options-&gt;merge($options); 
  }

  /**
   * Returns the current charset
   *
   * @return string
   **/
  public function getCharset()
  {
    return $this-&gt;charset;
  }

  public function getErrors()
  {
    return $this-&gt;errors;
  }

  /**
   * Returns the options of the current instance.
   *
   * @return array The current instance's options
   **/
  public function getOptions()
  {
    return $this-&gt;options;
  }

  /**
   * Initializes the parser according to the input string and charset.
   *
   * If passed a Source\String object, initializes according to it.
   *
   * @param string|Source\String $text
   * @param string               $charset
   **/
  protected function _init($text, $charset=null)
  {
    // options
    $this-&gt;strict_parsing = $this-&gt;options-&gt;get('strict_parsing');

    if($text instanceof Source\String) {
      $this-&gt;source = $text;
    } else {
      $this-&gt;source = new Source\String($text, $charset);
    }
    $this-&gt;text = $this-&gt;source-&gt;getContents();
    $this-&gt;current_position = 0;
    $this-&gt;charset = $this-&gt;source-&gt;getEncoding();
    $this-&gt;is_ascii_compatible_encoding = Charset::isAsciiCompatible($this-&gt;charset);
    $this-&gt;length = $this-&gt;source-&gt;getLength();
    $this-&gt;state = new ParserState();
    $this-&gt;errors = array();
  }

  protected function _pushError(ParseException $e)
  {
    $this-&gt;errors[] = new RecoveredParseException($e, $this-&gt;backtracking_position, $this-&gt;current_position);
  }
  protected function _setBacktrackingPosition()
  {
    $this-&gt;backtracking_position = $this-&gt;current_position;
  }
  protected function _backtrack()
  {
    $this-&gt;current_position = $this-&gt;backtracking_position;
  }

  protected function _isAsciiCaseInsensitiveMatch($str, $ascii)
  {
    if(!$this-&gt;is_ascii_compatible_encoding) {
      $str = mb_convert_encoding($str, 'ascii', $this-&gt;charset);
    }
    return 0 === strcasecmp($str, $ascii);
  }

  /**
   * Parses a single character.
   *
   * @param bool $isForIdentifier true if the character is part of an identifier
   *
   * @return string the parsed character
   **/
  protected function _parseCharacter($isForIdentifier)
  {
    if($this-&gt;_peek() === '\\') {

      $this-&gt;_consume('\\');
      if($this-&gt;_comes('\n') || $this-&gt;_comes('\r')) {
        return '';
      }
      if(!preg_match('/^[0-9a-fA-F]$/u', $this-&gt;_peek())) {
        return $this-&gt;_consume(1);
      }
      $codepoint = $this-&gt;_consumeExpression('/^[0-9a-fA-F]{1,6}/uS');
      if(mb_strlen($codepoint, $this-&gt;charset) &lt; 6) {
        //Consume whitespace after incomplete unicode escape
        if(preg_match('/^\s/u', $this-&gt;_peek())) {
          if($this-&gt;_comes('\r\n')) {
            $this-&gt;_consume(2);
          } else {
            $this-&gt;_consume(1);
          }
        }
      }
      $unicode_byte = intval($codepoint, 16);
      $utf_32_str = &quot;&quot;;
      for($i = 0; $i &lt; 4; $i++) {
        $utf_32_str .= chr($unicode_byte &amp; 0xff);
        $unicode_byte = $unicode_byte &gt;&gt; 8;
      }
      $char = Util\Charset::convert($utf_32_str, $this-&gt;charset, 'UTF-32LE');
      return $char;
    }

    if($isForIdentifier) {

      if(preg_match('/^[*a-zA-Z0-9_-]/uS', $this-&gt;_peek())) {
        return $this-&gt;_consume(1);
      } else if(ord($this-&gt;_peek()) &gt; 0xa1) {
        return $this-&gt;_consume(1);
      } else {
        return null;
      }

    } else {

      return $this-&gt;_consume(1);

    }
    // Does not reach here
    return null;
  }

  /**
   * Checks if a given string is found after the current position.
   *
   * @param string $string The string to search for.
   * @param int    $offset The offset at which it should be found.
   *
   * @return bool
   **/
  protected function _comes($string, $offset = 0)
  {
    if($this-&gt;_isEnd()) {
      return false;
    }
    return $this-&gt;_peek($string, $offset) === $string;
  }

  /**
   * Returns a peek at the input after the current position.
   *
   * @param int|string $length The peek length. If string will be the length of the string.
   * @param int|string $offset The offset at which to start the peek. If string will be the length of the string.
   *
   * @return string
   **/
  protected function _peek($length = 1, $offset = 0)
  {
    if($this-&gt;_isEnd()) {
      return '';
    }
    if(is_string($length)) {
      $length = mb_strlen($length, $this-&gt;charset);
    }
    if(is_string($offset)) {
      $offset = mb_strlen($offset, $this-&gt;charset);
    }
    return mb_substr($this-&gt;text, $this-&gt;current_position + $offset, $length, $this-&gt;charset);
  }

  /**
   * Consumes the input string
   *
   * @param string|int $value If string tries to consume the given string,
   *                          if int consumes the given number of characters.
   *
   * @return string The consumed input.
   **/
  protected function _consume($value = 1)
  {
    if(is_string($value)) {

      $length = mb_strlen($value, $this-&gt;charset);
      if(mb_substr($this-&gt;text, $this-&gt;current_position, $length, $this-&gt;charset) !== $value) {
        throw new ParseException(sprintf(
          'Expected &quot;%s&quot;, got &quot;%s&quot;',
          $value, $this-&gt;_peek(12)
        ), $this-&gt;source, $this-&gt;current_position);
      }
      $this-&gt;current_position += mb_strlen($value, $this-&gt;charset);
      return $value;

    } else {

      if($this-&gt;current_position + $value &gt; $this-&gt;length) {
        throw new ParseException(sprintf(
          'Tried to consume %d chars, exceeded file end', $value
        ), $this-&gt;source, $this-&gt;current_position);
      }
      $result = mb_substr($this-&gt;text, $this-&gt;current_position, $value, $this-&gt;charset);
      $this-&gt;current_position += $value;
      return $result;

    }
  }

  /**
   * Consumes a given regular expression.
   *
   * @param string $pattern A regex pattern.
   *
   * @return string The consumed expression.
   **/
  protected function _consumeExpression($pattern)
  {
    if(preg_match($pattern, $this-&gt;_inputLeft(), $matches, PREG_OFFSET_CAPTURE) === 1) {
      return $this-&gt;_consume($matches[0][0]);
    }
    throw new ParseException(sprintf(
      'Expected pattern &quot;%s&quot; not found, got: &quot;%s&quot;',
      $pattern, $this-&gt;_peek(12)
    ), $this-&gt;source, $this-&gt;current_position);
  }

  /**
   * Consumes whitespace and comments.
   **/
  protected function _consumeWhiteSpace()
  {
    do {
      while(preg_match('/\\s/isSu', $this-&gt;_peek()) === 1) {
        $this-&gt;_consume(1);
      }
    } while($this-&gt;_consumeComment());
  }

  protected function _consumeComment()
  {
    if($this-&gt;_comes('/*')) {
      $this-&gt;_consumeUntil('*/');
      $this-&gt;_consume('*/');
      return true;
    }
    return false;
  }

  /**
   * Checks for the end of input
   *
   * @return bool
   **/
  protected function _isEnd()
  {
    return $this-&gt;current_position &gt;= $this-&gt;length;
  }

  /**
   * Consumes input until the given string is found.
   *
   * @param string $end The string until which we consume input.
   *
   * @return string The consumed input
   **/
  protected function _consumeUntil($end)
  {
    $end_pos = mb_strpos($this-&gt;text, $end, $this-&gt;current_position, $this-&gt;charset);
    if($end_pos === false) {
      throw new ParseException(sprintf(
        'Required &quot;%s&quot; not found, got &quot;%s&quot;',
        $end, $this-&gt;_peek(12)
      ), $this-&gt;source, $this-&gt;current_position);
    }
    return $this-&gt;_consume($end_pos - $this-&gt;current_position);
  }

  /**
   * Returns the input string from current position to end
   *
   * @return string
   **/
  protected function _inputLeft()
  {
    return mb_substr($this-&gt;text, $this-&gt;current_position, $this-&gt;length, $this-&gt;charset);
  }

}
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all()
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>