<html>
    <head>
        <script
            type="text/javascript"
            src="../../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php
namespace ju1ius\Css\XPath;

use ju1ius\Css\Selector\ElementSelector;

/**
 * Represents an XPath expression.
 *
 * This component is a port of the Python lxml library,
 * which is copyright Infrae and distributed under the BSD license.
 *
 * @package Css
 * @subpackage XPath
 * @author Fabien Potencier &lt;fabien@symfony.com&gt;
 */
class Expression
{
  private $prefix;
  private $path;
  private $element;
  private $condition;
  private $starPrefix;

  /**
   * Constructor.
   *
   * @param string  $prefix     Prefix for the XPath expression.
   * @param string  $path       Actual path of the expression.
   * @param string  $element    The element in the expression.
   * @param string  $condition  A condition for the expression.
   * @param Boolean $starPrefix Indicates whether to use a star prefix.
   */
  public function __construct($prefix = null, $path = null, $element = '*', $condition = null, $starPrefix = false)
  {
    $this-&gt;prefix = $prefix;
    $this-&gt;path = $path;
    $this-&gt;element = $element;
    $this-&gt;condition = $condition;
    $this-&gt;starPrefix = $starPrefix;
  }

  /**
   * Gets the prefix of this XPath expression.
   *
   * @return string
   */
  public function getPrefix()
  {
    return $this-&gt;prefix;
  }

  /**
   * Gets the path of this XPath expression.
   *
   * @return string
   */
  public function getPath()
  {
    return $this-&gt;path;
  }

  /**
   * Answers whether this XPath expression has a star prefix.
   *
   * @return Boolean
   */
  public function hasStarPrefix()
  {
    return $this-&gt;starPrefix;
  }

  /**
   * Gets the element of this XPath expression.
   *
   * @return string
   */
  public function getElement()
  {
    return $this-&gt;element;
  }

  /**
   * Gets the condition of this XPath expression.
   *
   * @return string
   */
  public function getCondition()
  {
    return $this-&gt;condition;
  }

  /**
   * Gets a string representation for this XPath expression.
   *
   * @return string
   */
  public function __toString()
  {
    $path = '';
    if (null !== $this-&gt;prefix)
    {
      $path .= $this-&gt;prefix;
    }
    if (null !== $this-&gt;path)
    {
      $path .= $this-&gt;path;
    }
    $path .= $this-&gt;element;
    if ($this-&gt;condition)
    {
      $path .= sprintf('[%s]', $this-&gt;condition);
    }
    return $path;
  }

  /**
   * Adds a condition to this XPath expression.
   * Any pre-existent condition will be ANDed to it.
   *
   * @param string $condition The condition to add.
   */
  public function addCondition($condition)
  {
    if ($this-&gt;condition)
    {
      $this-&gt;condition = sprintf('%s and (%s)', $this-&gt;condition, $condition);
    }
    else
    {
      $this-&gt;condition = $condition;
    }
  }

  /**
   * Adds a prefix to this XPath expression.
   * It will be prepended to any pre-existent prefixes.
   *
   * @param string $prefix  The prefix to add.
   */
  public function addPrefix($prefix)
  {
    if ($this-&gt;prefix)
    {
      $this-&gt;prefix = $prefix.$this-&gt;prefix;
    }
    else
    {
      $this-&gt;prefix = $prefix;
    }
  }

  /**
   * Adds a condition to this XPath expression using the name of the element
   * as the desired value.
   * This method resets the element to '*'.
   */
  public function addNameTest()
  {
    if ($this-&gt;element == '*')
    {
      // We weren't doing a test anyway
      return;
    }
    $this-&gt;addCondition(sprintf('name() = %s', Expression::xpathLiteral($this-&gt;element)));
    $this-&gt;element = '*';
  }

  /**
   * Adds a star prefix to this XPath expression.
   * This method will prepend a '*' to the path and set the star prefix flag
   * to true.
   */
  public function addStarPrefix()
  {
    /*
      Adds a /* prefix if there is no prefix.  This is when you need
      to keep context's constrained to a single parent.
    */
    if ($this-&gt;path)
    {
      $this-&gt;path .= '*/';
    }
    else
    {
      $this-&gt;path = '*/';
    }
    $this-&gt;starPrefix = true;
  }

  /**
   * Joins this XPath expression with $other (another XPath expression) using
   * $combiner to join them.
   *
   * @param string    $combiner The combiner string.
   * @param XPathExpr $other    The other XPath expression to combine with
   *                            this one.
   */
  public function join($combiner, $other)
  {
    $prefix = (string) $this;

    $prefix .= $combiner;
    $path = $other-&gt;getPrefix().$other-&gt;getPath();

    /* We don't need a star prefix if we are joining to this other
      prefix; so we'll get rid of it */
    if ($other-&gt;hasStarPrefix() &amp;&amp; '*/' == $path)
    {
      $path = '';
    }
    $this-&gt;prefix = $prefix;
    $this-&gt;path = $path;
    $this-&gt;element = $other-&gt;getElement();
    $this-&gt;condition = $other-&gt;GetCondition();
  }

  /**
   * Gets an XPath literal for $s.
   *
   * @param  mixed $s Can either be a Node\ElementNode or a string.
   *
   * @return string
   */
  static public function xpathLiteral($s)
  {
    if ($s instanceof ElementSelector)
    {
      // This is probably a symbol that looks like an expression...
      $s = $s-&gt;getCssText();
    }
    else
    {
      $s = (string) $s;
    }
    if (false === strpos($s, &quot;'&quot;))
    {
      return sprintf(&quot;'%s'&quot;, $s);
    }
    if (false === strpos($s, '&quot;'))
    {
      return sprintf('&quot;%s&quot;', $s);
    }
    $string = $s;
    $parts = array();
    while (true)
    {
      if (false !== $pos = strpos($string, &quot;'&quot;))
      {
        $parts[] = sprintf(&quot;'%s'&quot;, substr($string, 0, $pos));
        $parts[] = &quot;\&quot;'\&quot;&quot;;
        $string = substr($string, $pos + 1);
      }
      else
      {
        $parts[] = &quot;'$string'&quot;;
        break;
      }
    }

    return sprintf('concat(%s)', implode($parts, ', '));
  }
}

</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all()
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>