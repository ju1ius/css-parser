<html>
    <head>
        <script
            type="text/javascript"
            src="../../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php
namespace ju1ius\Css\StyleDeclaration;

use ju1ius\Css\Serializable;
use ju1ius\Css\Util\Object;
use ju1ius\Css\StyleDeclaration;
use ju1ius\Css\PropertyValueList;
use ju1ius\Css\Property;
use ju1ius\Css\Value;


/**
 * Utility class to create shorthand properties from a StyleDeclaration
 *
 * @package Css
 * @subpackage StyleDeclaration
 **/
class CreateShorthands
{
  private $styleDeclaration;

  /**
   * Constructor
   *
   * @param ju1ius\Css\StyleDeclaration $styleDeclaration
   **/
  public function __construct(StyleDeclaration $styleDeclaration)
  {
    $this-&gt;styleDeclaration = $styleDeclaration;
  }

  /**
   * Create shorthand properties (e.g. `margin` or `font`) whenever possible.
   **/
  public function createShorthands()
  {
    $this-&gt;createBackgroundShorthand();
    $this-&gt;createDimensionsShorthands();
    // border must be shortened after dimensions 
    $this-&gt;createBorderShorthand();
    $this-&gt;createFontShorthand();
		$this-&gt;createListStyleShorthand();
  }

  /**
   *
   * @todo Handle background-color
   *
   **/
  public function createBackgroundShorthand()
  {
    $aProperties = array(
      'background-image', 'background-position',
      // &lt;bg-position&gt; [ / &lt;bg-size&gt; ]? syntax not yet supported as of Firefox 7
      /* 'background-size', */
      'background-repeat', 'background-attachment',
      'background-origin', 'background-clip'
    );
    $oBgImageProperty = $this-&gt;styleDeclaration-&gt;getAppliedProperty('background-image');
    $oBgColorProperty = $this-&gt;styleDeclaration-&gt;getAppliedProperty('background-color');
    // we need at least a background-image or a background-color
    if(!$oBgImageProperty &amp;&amp; !$oBgColorProperty) return;
    // get the number of layers from background-image property
    $iNumLayers = 1;
    if($oBgImageProperty) {
      $oBgImageValueList = $oBgImageProperty-&gt;getValueList();
      if($oBgImageValueList-&gt;getSeparator() === ',') {
        $iNumLayers = count($oBgImageValueList);
      }
    }
    if($iNumLayers === 1) {
      $aProperties[] = 'background-color';
      $this-&gt;_createShorthandProperties($aProperties, 'background', true);
      return;
    }
    $bCanProceed = $this-&gt;_safeCleanup($aProperties, 'background');
    if(!$bCanProceed) return;
    // Now we collapse the rules
    $aNewValues = array('normal' =&gt; array(), 'important' =&gt; array());
    $aOldProperties = array('normal' =&gt; array(), 'important' =&gt; array());
    foreach($aProperties as $sProperty) {
      $oProperty = $this-&gt;styleDeclaration-&gt;getAppliedProperty($sProperty);
      if(!$oProperty) continue;
      $sDest = $oProperty-&gt;getIsImportant() ? 'important' : 'normal';
      $oValueList = $oProperty-&gt;getValueList();
      if($oValueList-&gt;getSeparator() === ',') {
        $aPropertyLayers = $oValueList-&gt;getItems();
      } else {
        $aPropertyLayers = array($oValueList-&gt;getItems());
      }
      $aOldProperties[$sDest][] = $oProperty;
      // compute missing layers
      while(count($aPropertyLayers) &lt; $iNumLayers) {
        $aPropertyLayers = array_merge($aPropertyLayers, Object::getClone($aPropertyLayers));
      }
      // drop extra layers
      $aPropertyLayers = array_slice($aPropertyLayers, 0, $iNumLayers);
      //
      foreach($aPropertyLayers as $i =&gt; $mValue) {
        $aNewValues[$sDest][$i][$sProperty] = Object::getClone($mValue);
      }
    }
    if($oBgColorProperty) {
      $sDest = $oBgColorProperty-&gt;getIsImportant() ? 'important' : 'normal';
      $aOldProperties[$sDest][] = $oBgColorProperty;
      $aNewValues[$sDest][$iNumLayers-1]['background-color'] = Object::getClone(
        $oBgColorProperty-&gt;getValueList()-&gt;getFirst()
      );
      
    }
    $iImportantCount = count($aNewValues['important']);
    $iNormalCount = count($aNewValues['normal']);
    // Merge important values only if no normal values are present
    if($iNormalCount) {
      $this-&gt;_mergeLayers('background', $aNewValues['normal'], $aOldProperties['normal'], false);
    } else if($iImportantCount) {
      $this-&gt;_mergeLayers('background', $aNewValues['important'], $aOldProperties['important'], true);
    }
	}

  public function createListStyleShorthand()
  {
		$aProperties = array(
			'list-style-type', 'list-style-position', 'list-style-image'
		);
		$this-&gt;_createShorthandProperties($aProperties, 'list-style');
	}

  /**
   * Combine border-color, border-style and border-width into border
   * Should be run after create_dimensions_shorthand!
   **/
  public function createBorderShorthand()
  {
    $aProperties = array(
      'border-width', 'border-style', 'border-color' 
    );
		$this-&gt;_createShorthandProperties($aProperties, 'border');
  }

  /**
   * Looks for long format Css dimensional properties
   * (margin, padding, border-color, border-style and border-width) 
   * and converts them into shorthand Css properties.
   **/
  public function createDimensionsShorthands()
  {
    $aPositions = array('top', 'right', 'bottom', 'left');
    $aExpansions = array(
      'margin'       =&gt; 'margin-%s',
      'padding'      =&gt; 'padding-%s',
      'border-color' =&gt; 'border-%s-color', 
      'border-style' =&gt; 'border-%s-style', 
      'border-width' =&gt; 'border-%s-width'
    );
    $aProperties = $this-&gt;styleDeclaration-&gt;getProperties();
    $iImportantCount = 0;
    foreach($aExpansions as $sProperty =&gt; $sExpanded) {
      $aFoldable = array();
			foreach($aPositions as $sPosition) {
        $oProperty = $this-&gt;styleDeclaration-&gt;getAppliedProperty(
          sprintf($sExpanded, $sPosition)
        );
        if(!$oProperty) continue;
        if($oProperty-&gt;getIsImportant()) $iImportantCount++;
				$aFoldable[$oProperty-&gt;getName()] = $oProperty; 
			}
      // All four dimensions must be present
      if(count($aFoldable) !== 4) continue;
      // All four dimensions must have same importance
      if($iImportantCount &amp;&amp; $iImportantCount !== 4) continue;

      $aValues = array();
      foreach($aPositions as $sPosition) {
        $oProperty = $aFoldable[sprintf($sExpanded, $sPosition)];
        $aPropertyValues = $oProperty-&gt;getValueList()-&gt;getItems();
        $aValues[$sPosition] = Object::getClone($aPropertyValues[0]);
      }
      $oNewValueList = new PropertyValueList(array(), ' ');
      
      if((string)$aValues['left'] === (string)$aValues['right']) {
        if((string)$aValues['top'] === (string)$aValues['bottom']) {
          if((string)$aValues['top'] === (string)$aValues['left']) {
            // All 4 sides are equal
            $oNewValueList-&gt;append($aValues['top']);
          } else {
            // Top and bottom are equal, left and right are equal
            $oNewValueList-&gt;append($aValues['top']);
            $oNewValueList-&gt;append($aValues['left']);
          }
        } else {
          // Only left and right are equal
          $oNewValueList-&gt;append($aValues['top']);
          $oNewValueList-&gt;append($aValues['left']);
          $oNewValueList-&gt;append($aValues['bottom']);
        }
      } else {
        // No sides are equal 
        $oNewValueList-&gt;append($aValues['top']);
        $oNewValueList-&gt;append($aValues['right']);
        $oNewValueList-&gt;append($aValues['bottom']);
        $oNewValueList-&gt;append($aValues['left']);
      }
      $oNewProperty = new Property($sProperty, $oNewValueList);
      $oNewProperty-&gt;setIsImportant(!!$iImportantCount);
      $this-&gt;styleDeclaration-&gt;append($oNewProperty);
      foreach ($aPositions as $sPosition)
      {
        $this-&gt;styleDeclaration-&gt;remove(sprintf($sExpanded, $sPosition));
      }
    }
  }

  /**
   * Looks for long format Css font properties (e.g. &lt;tt&gt;font-weight&lt;/tt&gt;) and 
   * tries to convert them into a shorthand Css &lt;tt&gt;font&lt;/tt&gt; property. 
   * At least font-size AND font-family must be present in order to create a shorthand declaration.
   **/
  public function createFontShorthand()
  {
    $aFontProperties = array(
      'font-style', 'font-variant', 'font-weight', 'font-size', 'line-height', 'font-family'
    );
    $oFSProperty = $this-&gt;styleDeclaration-&gt;getAppliedProperty('font-size');
    $oFFProperty = $this-&gt;styleDeclaration-&gt;getAppliedProperty('font-family');
    if(!$oFSProperty || !$oFFProperty) return;
    $oNewValueList = new PropertyValueList(array(), ' ');
    foreach(array('font-style', 'font-variant', 'font-weight') as $sProperty) {
			$oProperty = $this-&gt;styleDeclaration-&gt;getAppliedProperty($sProperty);
			if(!$oProperty) continue;
			$aValues = $oProperty-&gt;getValueList()-&gt;getItems();
			if($aValues[0] !== 'normal') {
				$oNewValueList-&gt;append(Object::getClone($aValues[0]));
			}
    }
    // Get the font-size value
    $aFSValues = $oFSProperty-&gt;getValueList()-&gt;getItems();
    // But wait to know if we have line-height to add it
		$oLHProperty = $this-&gt;styleDeclaration-&gt;getAppliedProperty('line-height');
    if($oLHProperty) {
      $aLHValues = $oLHProperty-&gt;getValueList()-&gt;getItems();
      if('normal' !== $aLHValues[0]) {
        $val = new PropertyValueList(
          array(
            Object::getClone($aFSValues[0]),
            Object::getClone($aLHValues[0])
          ),
          '/'
        );
        $oNewValueList-&gt;append($val);
      } else {
        $oNewValueList-&gt;append(Object::getClone($aFSValues[0]));
      }
    } else {
      $oNewValueList-&gt;append(Object::getClone($aFSValues[0]));
    }
		// Font-Family
    //$aFFValues = $oFFProperty-&gt;getValueList()-&gt;getItems();
		//$oFFValue = new PropertyValueList($aFFValues, ',');
    //$oNewValueList-&gt;append($oFFValue);
    $oNewValueList-&gt;append(Object::getClone($oFFProperty-&gt;getValueList()));

    $oNewProperty = new Property('font', $oNewValueList);
    $this-&gt;styleDeclaration-&gt;append($oNewProperty);
    $this-&gt;styleDeclaration-&gt;remove($aFontProperties);
	}

  private function _createShorthandProperties(array $aProperties, $sShorthand, $bSafe=false)
  {
    if($bSafe) {
      $bCanProceed = $this-&gt;_safeCleanup($aProperties, $sShorthand);
    } else {
      $bCanProceed = $this-&gt;_destructiveCleanup($aProperties, $sShorthand);
    }
    if(!$bCanProceed) return;
    // Now we collapse the rules
    $aNewValues = array('normal' =&gt; array(), 'important' =&gt; array());
    $aOldProperties = array('normal' =&gt; array(), 'important' =&gt; array());
    foreach($aProperties as $sProperty) {
      $aProperties = $this-&gt;styleDeclaration-&gt;getProperties($sProperty);
      foreach($aProperties as $iPos =&gt; $oProperty) {
        $aValues = $oProperty-&gt;getValueList()-&gt;getItems();
        $sDest = $oProperty-&gt;getIsImportant() ? 'important' : 'normal';
        $aOldProperties[$sDest][] = $iPos;
        foreach($aValues as $mValue) {
          $aNewValues[$sDest][] = Object::getClone($mValue);
        }
      }
    }
    $iImportantCount = count($aNewValues['important']);
    $iNormalCount = count($aNewValues['normal']);
    // Merge important values only if no normal values are present
    if($iNormalCount) {
      $this-&gt;_mergeValues($sShorthand, $aNewValues['normal'], $aOldProperties['normal'], false);
    } else if($iImportantCount) {
      $this-&gt;_mergeValues($sShorthand, $aNewValues['important'], $aOldProperties['important'], true);
    }
  }

  private function _mergeLayers($sShorthand, $aLayers, $aOldProperties, $bImportant)
  {
    $this-&gt;styleDeclaration-&gt;remove($aOldProperties);
    $oNewValueList = new PropertyValueList(array(), ',');
    foreach($aLayers as $aValues) {
      $oLayerValueList = new PropertyValueList($aValues, ' ');
      $oNewValueList-&gt;append($oLayerValueList);
    }
    $oNewProperty = new Property($sShorthand, $oNewValueList);
    $oNewProperty-&gt;setIsImportant($bImportant);
    $this-&gt;styleDeclaration-&gt;append($oNewProperty);
  }

  private function _mergeValues($sShorthand, $aValues, $aOldProperties, $bImportant)
  {
    $this-&gt;styleDeclaration-&gt;remove($aOldProperties);
    $oNewValueList = new PropertyValueList($aValues, ' ');
    $oNewProperty = new Property($sShorthand, $oNewValueList);
    $oNewProperty-&gt;setIsImportant($bImportant);
    $this-&gt;styleDeclaration-&gt;append($oNewProperty);
  }
  
  /**
   * Destructively cleans up rules before creating shorthand properties.
   * Keeps only significant properties according to their
   * respective order and importance.
   * This is the method we want to use in most cases.
   *
   **/
  private function _destructiveCleanup(Array $aProperties, $sShorthand) {
    // first we check if a shorthand already exists, and keep only the relevant one.
    $aLastExistingShorthand = $this-&gt;styleDeclaration-&gt;getAppliedProperty($sShorthand, true);
    if($aLastExistingShorthand) {
      list($iLastExistingShorthandPosition, $oLastExistingShorthand) = each($aLastExistingShorthand);
    }
    foreach($this-&gt;styleDeclaration-&gt;getProperties($sShorthand) as $iPos =&gt; $oProperty) {
      if($iPos !== $iLastExistingShorthandPosition) $this-&gt;styleDeclaration-&gt;remove($iPos);
    }
    // next we try to get rid of unused rules
    foreach($aProperties as $sProperty) {
      $aRule = $this-&gt;styleDeclaration-&gt;getAppliedProperty($sProperty, true);
      if(!$aRule) continue;
      list($iRulePosition, $oRule) = each($aRule);
			foreach($this-&gt;styleDeclaration-&gt;getProperties($sProperty) as $iPos =&gt; $oProperty) {
        if($iPos !== $iRulePosition) $this-&gt;styleDeclaration-&gt;remove($iPos);
      }
      if($aLastExistingShorthand) {
        $bRuleIsImportant = $oRule-&gt;getIsImportant();
        $bShorthandIsImportant = $oLastExistingShorthand-&gt;getIsImportant();
        // IF property comes before shorthand AND they have the same importance,
        // OR IF shorthand is important AND property is not,
        // we can get rid of the property.
        if(($iRulePosition &lt; $iLastExistingShorthandPosition &amp;&amp; $bRuleIsImportant === $bShorthandIsImportant)
           || (!$bRuleIsImportant &amp;&amp; $bShorthandIsImportant)) {
          $this-&gt;styleDeclaration-&gt;remove($iRulePosition);
        }
      }
    }
    if($aLastExistingShorthand) {
      // Now that we made sure that there is no duplicate shorthand
      // we can expand the corresponding rule as expanding doesn't create duplicates.
      $sExpandMethod = 'expand'.str_replace(' ', '', ucwords(str_replace('-', ' ', $sShorthand))).'Shorthands';
      $this-&gt;styleDeclaration-&gt;$sExpandMethod();
    }
    return true;
  }

  /**
   * Safely cleans up properties before creating shorthand properties.
   * Avoids creating a shorthand if:
   * &lt;ul&gt;
   *   &lt;li&gt;
   *     More than one shorthand is already present,
   *     as it is generally done on purpose, ie for vendor specific values.
   *     &lt;code&gt;
   *       background: -webkit-linear-gradient(#000, #fff);
   *       background: -moz-linear-gradient(#000, #fff);
   *     &lt;/code&gt;
   *   &lt;/li&gt;
   *   &lt;li&gt;
   *     More than one identical properties are found,
   *     for the very same reasons
   *   &lt;/li&gt;
   * &lt;/ul&gt;
   *
   * @return bool True if collapsing can continue after cleanup, false otherwise
   **/
  private function _safeCleanup(Array $aProperties, $sShorthand) {
    $aExistingShorthands = $this-&gt;styleDeclaration-&gt;getProperties($sShorthand);
    $iNumShorthands = count($aExistingShorthands);
    // Don't create shorthands if more than one are already present,
    if($iNumShorthands &gt; 1) return false;
    if($iNumShorthands === 1) {
      $iExistingShorthandPosition = key($aExistingShorthands);
    }
    foreach($aProperties as $sProperty) {
      $aProperties = $this-&gt;styleDeclaration-&gt;getProperties($sProperty);
      // Don't merge anything if several identical rules are present.
      if(count($aProperties) &gt; 1) return false;
      // Can't merge property if no value
      if(count($aProperties) === 0) continue;
			foreach($aProperties as $iPos =&gt; $oProperty) {
        if($iNumShorthands &amp;&amp; !$oProperty-&gt;getIsImportant() &amp;&amp; $iPos &lt; $iExistingShorthandPosition) {
          // If rule is not important and comes before a shorthand, we can safely remove it.
          $this-&gt;styleDeclaration-&gt;remove($iPos);
          continue;
				}
      }
    }
    if($iNumShorthands) {
      // Now that we made sure that there is no duplicate shorthand
      // we can expand the corresponding property as expanding doesn't create duplicates.
      $sExpandMethod = 'expand'.str_replace(' ', '', ucwords(str_replace('-', ' ', $sShorthand))).'Shorthands';
      $this-&gt;styleDeclaration-&gt;$sExpandMethod();
    }
    return true;
  }
}
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all()
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>