<html>
    <head>
        <script
            type="text/javascript"
            src="../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php

namespace ju1ius\Css;

use ju1ius\Text\Source;
use ju1ius\Css\Exception\ParseException;
use ju1ius\Css\Util\Charset;

class AsciiParser extends Parser
{
  /**
   * Initializes the parser according to the input string and charset.
   *
   * If passed a Source\String object, initializes according to it.
   *
   * @param string|Source\String $text
   * @param string               $charset
   **/
  protected function _init($text, $charset=null)
  {
    // options
    $this-&gt;strict_parsing = $this-&gt;options-&gt;get('strict_parsing');

    if($text instanceof Source\String) {
      $this-&gt;source = $text;
    } else {
      $this-&gt;source = new Source\String($text, $charset);
    }
    $this-&gt;text = $this-&gt;source-&gt;getContents();
    $this-&gt;current_position = 0;
    $this-&gt;charset = $this-&gt;source-&gt;getEncoding();
    if(!Charset::isSameEncoding($this-&gt;charset, 'ascii')) {
      throw new \RuntimeException(&quot;AcsiiParser can only be used with ASCII files&quot;);
    }
    $this-&gt;is_ascii_compatible_encoding = true;
    $this-&gt;length = $this-&gt;source-&gt;getLength();
    $this-&gt;state = new ParserState();
    $this-&gt;errors = array();
  }

  private function _parseColorValue()
  {/*{{{*/
    if($this-&gt;_comes('#')) {
      $this-&gt;_consume('#');
      $value = $this-&gt;_parseIdentifier();
      return new Value\Color($value);
    } else {
      $colors = array();
      $colorMode = $this-&gt;_parseIdentifier();
      $this-&gt;_consumeWhiteSpace();
      $this-&gt;_consume('(');
      $length = strlen($colorMode, $this-&gt;charset);
      for($i = 0; $i &lt; $length; $i++) {
        $this-&gt;_consumeWhiteSpace();
        $colors[$colorMode[$i]] = $this-&gt;_parseNumericValue(true);
        $this-&gt;_consumeWhiteSpace();
        if($i &lt; ($length - 1)) {
          $this-&gt;_consume(',');
        }
      }
      $this-&gt;_consume(')');
      return new Value\Color($colors);
    }
  }/*}}}*/

  protected function _isAsciiCaseInsensitiveMatch($str, $ascii)
  {
    return 0 === strcasecmp($str, $ascii);
  }

  /**
   * Parses a single character.
   *
   * @param bool $isForIdentifier true if the character is part of an identifier
   *
   * @return string the parsed character
   **/
  protected function _parseCharacter($isForIdentifier)
  {
    if($this-&gt;_peek() === '\\') {

      $this-&gt;_consume('\\');
      if($this-&gt;_comes('\n') || $this-&gt;_comes('\r')) {
        return '';
      }
      if(!preg_match('/^[0-9a-fA-F]$/', $this-&gt;_peek())) {
        return $this-&gt;_consume(1);
      }
      $codepoint = $this-&gt;_consumeExpression('/^[0-9a-fA-F]{1,6}/S');
      if(strlen($codepoint) &lt; 6) {
        //Consume whitespace after incomplete unicode escape
        if(preg_match('/^\s/', $this-&gt;_peek())) {
          if($this-&gt;_comes('\r\n')) {
            $this-&gt;_consume(2);
          } else {
            $this-&gt;_consume(1);
          }
        }
      }
      $unicode_byte = intval($codepoint, 16);
      $utf_32_str = &quot;&quot;;
      for($i = 0; $i &lt; 4; $i++) {
        $utf_32_str .= chr($unicode_byte &amp; 0xff);
        $unicode_byte = $unicode_byte &gt;&gt; 8;
      }
      $char = Util\Charset::convert($utf_32_str, 'ascii', 'UTF-32LE');
      return $char;
    }

    if($isForIdentifier) {

      if(preg_match('/^[*a-zA-Z0-9_-]/S', $this-&gt;_peek())) {
        return $this-&gt;_consume(1);
      } else if(ord($this-&gt;_peek()) &gt; 0xa1) {
        return $this-&gt;_consume(1);
      } else {
        return null;
      }

    } else {

      return $this-&gt;_consume(1);

    }
    // Does not reach here
    return null;
  }
  /**
   * Returns a peek at the input after the current position.
   *
   * @param int|string $length The peek length. If string will be the length of the string.
   * @param int|string $offset The offset at which to start the peek. If string will be the length of the string.
   *
   * @return string
   **/
  protected function _peek($length = 1, $offset = 0)
  {
    if($this-&gt;_isEnd()) {
      return '';
    }
    if(is_string($length)) {
      $length = strlen($length);
    }
    if(is_string($offset)) {
      $offset = strlen($offset);
    }
    return substr($this-&gt;text, $this-&gt;current_position + $offset, $length);
  }

  /**
   * Consumes the input string
   *
   * @param string|int $value If string tries to consume the given string,
   *                          if int consumes the given number of characters.
   *
   * @return string The consumed input.
   **/
  protected function _consume($value = 1)
  {
    if(is_string($value)) {

      $length = strlen($value);
      if(substr($this-&gt;text, $this-&gt;current_position, $length) !== $value) {
        throw new ParseException(sprintf(
          'Expected &quot;%s&quot;, got &quot;%s&quot;',
          $value, $this-&gt;_peek(12)
        ), $this-&gt;source, $this-&gt;current_position);
      }
      $this-&gt;current_position += strlen($value);
      return $value;

    } else {

      if($this-&gt;current_position + $value &gt; $this-&gt;length) {
        throw new ParseException(sprintf(
          'Tried to consume %d chars, exceeded file end', $value
        ), $this-&gt;source, $this-&gt;current_position);
      }
      $result = substr($this-&gt;text, $this-&gt;current_position, $value);
      $this-&gt;current_position += $value;
      return $result;

    }
  }
  /**
   * Consumes whitespace and comments.
   **/
  protected function _consumeWhiteSpace()
  {
    do {
      while(preg_match('/\s/S', $this-&gt;_peek()) === 1) {
        $this-&gt;_consume(1);
      }
    } while($this-&gt;_consumeComment());
  }

  /**
   * Consumes input until the given string is found.
   *
   * @param string $end The string until which we consume input.
   *
   * @return string The consumed input
   **/
  protected function _consumeUntil($end)
  {
    $end_pos = strpos($this-&gt;text, $end, $this-&gt;current_position);
    if($end_pos === false) {
      throw new ParseException(sprintf(
        'Required &quot;%s&quot; not found, got &quot;%s&quot;',
        $end, $this-&gt;_peek(12)
      ), $this-&gt;source, $this-&gt;current_position);
    }
    return $this-&gt;_consume($end_pos - $this-&gt;current_position);
  }

  /**
   * Returns the input string from current position to end
   *
   * @return string
   **/
  protected function _inputLeft()
  {
    return substr($this-&gt;text, $this-&gt;current_position, $this-&gt;length);
  }
}
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all()
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>